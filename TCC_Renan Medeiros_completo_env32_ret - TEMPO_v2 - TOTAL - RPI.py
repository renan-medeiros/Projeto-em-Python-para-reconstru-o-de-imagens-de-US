#-------------------------------------------------------------------------
# Arquivo TCC 2
# Curso de Graduação em Engenharia Elétrica
# Autor:Renan Medeiros
# Data: 20/11/2019
# Dados de Entrada: Arquivo 'dados_beam_apo_delay.txt' do Sistema ULTRA-ORS
# Descrição: Projeto completo para processamento digital de sinais de US
#            para recontrução de imagem no Rasperry Pi
#-------------------------------------------------------------------------

import numpy as np
import matplotlib.pylab as plt
import time
import timeit

inicio = time.time()
start = timeit.default_timer()
print("Inicio: ", inicio)
print("Start: ", start)

s = np.zeros((2046,121))

env = np.zeros((2046,121))

env1 = np.zeros((2076,121)) #dimensão maior para poder deslocar

max_linhas = np.zeros((121,1))

limiar_inf = 200

def processamento():

    f_matriz = np.zeros((2046,8))

    y = np.zeros((2046,1))


    #------------------------------------------------------
    # Importando entrada do sinal de US a partir de um TXT
    #------------------------------------------------------

    with open('dados_beam_apo_delay.txt', 'r') as arquivo:
        z = arquivo.readlines()
    #print(z[0])
    
    w = np.zeros((2046,1))

    for k in range(0, 121):

        #------------
        # Filtragem
        #------------

        for r in range(0, 8):
            for i in range(0,2046):
                w[i] = z[i+r*2046+k*16368]

            x = w
            
            '''
            if k==0 and r==0:
                # Exportando dados para TXT    
                with open('teste_python_entrada1.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
                    for i in range(0, 2046, 1):
                        arquivo.write(str(x[i]) + '\n')
            #print(x[0])
            '''      

            # Vetor de saida (FIR)
            f = np.zeros((2046,1)) # dimensao 20461x1 - vetor de saida do filtro


            # Vetor de coeficientes (FIR)
            Coef_FIR = np.array ([-0.0080524653553576461, -0.020318830061531748, -0.028800534328365872, -0.01643518329923499, 0.030369681429219274, 0.10853961742278931, 0.19336131713263965, 0.24892007978955652, 0.24892007978955652, 0.19336131713263965, 0.10853961742278931, 0.030369681429219274, -0.01643518329923499, -0.028800534328365872, -0.020318830061531748, -0.0080524653553576461]);
            

            # 'A' recebe os coeficientes transpostos FIR
            a = Coef_FIR.T;


            # Convoluçao 
            f[0]=x[0]*a[0];
            f[1]=x[1]*a[0] + x[0]*a[1];
            f[2]=x[2]*a[0] + x[1]*a[1]+ x[0]*a[2];
            f[3]=x[3]*a[0] + x[2]*a[1]+ x[1]*a[2]+ x[0]*a[3];
            f[4]=x[4]*a[0] + x[3]*a[1]+ x[2]*a[2]+ x[1]*a[3]+ x[0]*a[4];
            f[5]=x[5]*a[0] + x[4]*a[1]+ x[3]*a[2]+ x[2]*a[3]+ x[1]*a[4]+ x[0]*a[5];
            f[6]=x[6]*a[0] + x[5]*a[1]+ x[4]*a[2]+ x[3]*a[3]+ x[2]*a[4]+ x[1]*a[5]+ x[0]*a[6];
            f[7]=x[7]*a[0] + x[6]*a[1]+ x[5]*a[2]+ x[4]*a[3]+ x[3]*a[4]+ x[2]*a[5]+ x[1]*a[6]+ x[0]*a[7];
            f[8]=x[8]*a[0] + x[7]*a[1]+ x[6]*a[2]+ x[5]*a[3]+ x[4]*a[4]+ x[3]*a[5]+ x[2]*a[6]+ x[1]*a[7]+ x[0]*a[8];
            f[9]=x[9]*a[0] + x[8]*a[1]+ x[7]*a[2]+ x[6]*a[3]+ x[5]*a[4]+ x[4]*a[5]+ x[3]*a[6]+ x[2]*a[7]+ x[1]*a[8]+ x[0]*a[9];
            f[10]=x[10]*a[0] + x[9]*a[1]+ x[8]*a[2]+ x[7]*a[3]+ x[6]*a[4]+ x[5]*a[5]+ x[4]*a[6]+ x[3]*a[7]+ x[2]*a[8]+ x[1]*a[9]+ x[0]*a[10];
            f[11]=x[11]*a[0] + x[10]*a[1]+ x[9]*a[2]+ x[8]*a[3]+ x[7]*a[4]+ x[6]*a[5]+ x[5]*a[6]+ x[4]*a[7]+ x[3]*a[8]+ x[2]*a[9]+ x[1]*a[10]+ x[0]*a[11];
            f[12]=x[12]*a[0] + x[11]*a[1]+ x[10]*a[2]+ x[9]*a[3]+ x[8]*a[4]+ x[7]*a[5]+ x[6]*a[6]+ x[5]*a[7]+ x[4]*a[8]+ x[3]*a[9]+ x[2]*a[10]+ x[1]*a[11]+ x[0]*a[12];
            f[13]=x[13]*a[0] + x[12]*a[1]+ x[11]*a[2]+ x[10]*a[3]+ x[9]*a[4]+ x[8]*a[5]+ x[7]*a[6]+ x[6]*a[7]+ x[5]*a[8]+ x[4]*a[9]+ x[3]*a[10]+ x[2]*a[11]+ x[1]*a[12]+ x[0]*a[13];
            f[14]=x[14]*a[0] + x[13]*a[1]+ x[12]*a[2]+ x[11]*a[3]+ x[10]*a[4]+ x[9]*a[5]+ x[8]*a[6]+ x[7]*a[7]+ x[6]*a[8]+ x[5]*a[9]+ x[4]*a[10]+ x[3]*a[11]+ x[2]*a[12]+ x[1]*a[13]+ x[0]*a[14];


            for i in range(15, 2046, 1):

                f[i]=x[i]*a[0] + x[i-1]*a[1]+ x[i-2]*a[2]+ x[i-3]*a[3]+ x[i-4]*a[4]+ x[i-5]*a[5]+ x[i-6]*a[6]+ x[i-7]*a[7]+ x[i-8]*a[8]+ x[i-9]*a[9]+ x[i-10]*a[10]+ x[i-11]*a[11]+ x[i-12]*a[12]+ x[i-13]*a[13]+x[i-14]*a[14]+x[i-15]*a[15]; 
            
            # monta matriz de uma scanline com 8 elementos na varredura (abertura)
            for i in range(0, 2046): 
                f_matriz[i][r] = f[i]
            
            '''     
            if k==0 and r==0:
            # Exportando dados para TXT    
                with open('teste_python_linha1.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
                    for i in range(0, 2046, 1):
                        arquivo.write(str(f_matriz[i][r]) + '\n')
            '''
            '''    
            if k==120:
            # Exportando dados para TXT    
                with open('teste_valor_apodizado_python_sc121.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
                    for r in range(0, 8, 1):
                        for i in range(0, 2046, 1):
                            arquivo.write(str(f_matriz[i][r]) + '\n')
                #print(f_matriz)
            '''
        #---------------
        # Soma coerente
        #---------------

        
        for i in range(0, 2046): 
            y[i] = f_matriz[i][0] + f_matriz[i][1] + f_matriz[i][2] + f_matriz[i][3] + f_matriz[i][4] + f_matriz[i][5] + f_matriz[i][6] + f_matriz[i][7];
        
        '''
        if k==0:
        # Exportando dados para TXT
            with open('teste_python_sc1.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
                for i in range(0, 2046, 1):
                    arquivo.write(str(y[i]) + '\n')
        #print(y[0])
        '''
                
        #-------------------------
        # Envoltória com ordem 32
        #-------------------------
                
        # Vetor de saida em Quadratura Q(t) - imaginário (Transformada de Hilbert)
        q = np.zeros((2046,1)) # dimensao 2046x1

        # Vetor de saida em Fase I(t) - real
        j = np.zeros((2046,1)) # dimensao 2046x1

        # Vetor de coeficientes (Hilbert)
        #Coef_hilbert = np.array ([0.000045448643348697757, -0.0319136045611684, 0, -0.0260478358874456, 0, -0.0373284021357407, 0, -0.0531107459937532, 0, -0.0766995375013514, 0, -0.116853826766850, 0, -0.205805810057241, 0, -0.634472629392063, 0, 0.634472629392063, 0, 0.205805810057241, 0, 0.116853826766850, 0, 0.0766995375013514, 0, 0.0531107459937532, 0, 0.0373284021357407, 0, 0.0260478358874456, 0, 0.0319136045611684, 0]);
        #Coef_hilbert = np.array ([4.54486433486978e-05, -0.0319136045611684, -3.31277815638996e-05, -0.0260478358874456, -1.59427170184714e-06,	-0.0373284021357407, 3.46942587573067e-06, -0.0531107459937532, -1.03378562693070e-06,	-0.0766995375013514, -5.96683448033613e-06, -0.116853826766850, 1.66624629077077e-05, -0.205805810057241, -1.89302802971109e-05, -0.634472629392063, 0,	0.634472629392063, 1.89302802971109e-05, 0.205805810057241, -1.66624629077077e-05, 0.116853826766850, 5.96683448033613e-06, 0.0766995375013514, 1.03378562693070e-06, 0.0531107459937532, -3.46942587573067e-06, 0.0373284021357407, 1.59427170184714e-06, 0.0260478358874456, 3.31277815638996e-05, 0.0319136045611684, -4.54486433486978e-05]);

        Coef_hilbert = np.array ([ 0.000045448643348697757, -0.031913604561168388, -0.00003312778156389956, -0.026047835887445595, -0.0000015942717018471429,	-0.037328402135740679,  0.0000034694258757306669, -0.053110745993753178, -0.0000010337856269306998, -0.076699537501351389, -0.0000059668344803361263, -0.11685382676685013,  0.00001666246290770766, -0.2058058100572413, -0.00001893028029711089, -0.63447262939206328, 0,  0.63447262939206328,  0.00001893028029711089,  0.2058058100572413, -0.00001666246290770766,  0.11685382676685013,  0.0000059668344803361263,  0.076699537501351389,  0.0000010337856269306998,  0.053110745993753178, -0.0000034694258757306669,  0.037328402135740679,  0.0000015942717018471429,  0.026047835887445595,  0.00003312778156389956,  0.031913604561168388, -0.000045448643348697757]);
        
        # 'B' recebe os coeficientes transpostos
        b = Coef_hilbert.T;

        #Envoltória 
        q[0]=y[0]*b[0];
        q[1]=y[1]*b[0]+ y[0]*b[1];
        q[2]=y[2]*b[0]+ y[1]*b[1]+ y[0]*b[2];
        q[3]=y[3]*b[0]+ y[2]*b[1]+ y[1]*b[2]+ y[0]*b[3];
        q[4]=y[4]*b[0]+ y[3]*b[1]+ y[2]*b[2]+ y[1]*b[3]+ y[0]*b[4];
        q[5]=y[5]*b[0]+ y[4]*b[1]+ y[3]*b[2]+ y[2]*b[3]+ y[1]*b[4]+ y[0]*b[5];
        q[6]=y[6]*b[0]+ y[5]*b[1]+ y[4]*b[2]+ y[3]*b[3]+ y[2]*b[4]+ y[1]*b[5]+ y[0]*b[6];
        q[7]=y[7]*b[0]+ y[6]*b[1]+ y[5]*b[2]+ y[4]*b[3]+ y[3]*b[4]+ y[2]*b[5]+ y[1]*b[6]+ y[0]*b[7];
        q[8]=y[8]*b[0]+ y[7]*b[1]+ y[6]*b[2]+ y[5]*b[3]+ y[4]*b[4]+ y[3]*b[5]+ y[2]*b[6]+ y[1]*b[7]+ y[0]*b[8];
        q[9]=y[9]*b[0]+ y[8]*b[1]+ y[7]*b[2]+ y[6]*b[3]+ y[5]*b[4]+ y[4]*b[5]+ y[3]*b[6]+ y[2]*b[7]+ y[1]*b[8]+ y[0]*b[9];
        q[10]=y[10]*b[0]+ y[9]*b[1]+ y[8]*b[2]+ y[7]*b[3]+ y[6]*b[4]+ y[5]*b[5]+ y[4]*b[6]+ y[3]*b[7]+ y[2]*b[8]+ y[1]*b[9]+ y[0]*b[10];
        q[11]=y[11]*b[0]+ y[10]*b[1]+ y[9]*b[2]+ y[8]*b[3]+ y[7]*b[4]+ y[6]*b[5]+ y[5]*b[6]+ y[4]*b[7]+ y[3]*b[8]+ y[2]*b[9]+ y[1]*b[10]+ y[0]*b[11];
        q[12]=y[12]*b[0]+ y[11]*b[1]+ y[10]*b[2]+ y[9]*b[3]+ y[8]*b[4]+ y[7]*b[5]+ y[6]*b[6]+ y[5]*b[7]+ y[4]*b[8]+ y[3]*b[9]+ y[2]*b[10]+ y[1]*b[11]+ y[0]*b[12];
        q[13]=y[13]*b[0]+ y[12]*b[1]+ y[11]*b[2]+ y[10]*b[3]+ y[9]*b[4]+ y[8]*b[5]+ y[7]*b[6]+ y[6]*b[7]+ y[5]*b[8]+ y[4]*b[9]+ y[3]*b[10]+ y[2]*b[11]+ y[1]*b[12]+ y[0]*b[13];
        q[14]=y[14]*b[0]+ y[13]*b[1]+ y[12]*b[2]+ y[11]*b[3]+ y[10]*b[4]+ y[9]*b[5]+ y[8]*b[6]+ y[7]*b[7]+ y[6]*b[8]+ y[5]*b[9]+ y[4]*b[10]+ y[3]*b[11]+ y[2]*b[12]+ y[1]*b[13]+ y[0]*b[14];
        q[15]=y[15]*b[0]+ y[14]*b[1]+ y[13]*b[2]+ y[12]*b[3]+ y[11]*b[4]+ y[10]*b[5]+ y[9]*b[6]+ y[8]*b[7]+ y[7]*b[8]+ y[6]*b[9]+ y[5]*b[10]+ y[4]*b[11]+ y[3]*b[12]+ y[2]*b[13]+ y[1]*b[14]+ y[0]*b[15];
        q[16]=y[16]*b[0]+ y[15]*b[1]+ y[14]*b[2]+ y[13]*b[3]+ y[12]*b[4]+ y[11]*b[5]+ y[10]*b[6]+ y[9]*b[7]+ y[8]*b[8]+ y[7]*b[9]+ y[6]*b[10]+ y[5]*b[11]+ y[4]*b[12]+ y[3]*b[13]+ y[2]*b[14]+ y[1]*b[15]+ y[0]*b[16];
        q[17]=y[17]*b[0]+ y[16]*b[1]+ y[15]*b[2]+ y[14]*b[3]+ y[13]*b[4]+ y[12]*b[5]+ y[11]*b[6]+ y[10]*b[7]+ y[9]*b[8]+ y[8]*b[9]+ y[7]*b[10]+ y[6]*b[11]+ y[5]*b[12]+ y[4]*b[13]+ y[3]*b[14]+ y[2]*b[15]+ y[1]*b[16]+ y[0]*b[17];
        q[18]=y[18]*b[0]+ y[17]*b[1]+ y[16]*b[2]+ y[15]*b[3]+ y[14]*b[4]+ y[13]*b[5]+ y[12]*b[6]+ y[11]*b[7]+ y[10]*b[8]+ y[9]*b[9]+ y[8]*b[10]+ y[7]*b[11]+ y[6]*b[12]+ y[5]*b[13]+ y[4]*b[14]+ y[3]*b[15]+ y[2]*b[16]+ y[1]*b[17]+ y[0]*b[18];
        q[19]=y[19]*b[0]+ y[18]*b[1]+ y[17]*b[2]+ y[16]*b[3]+ y[15]*b[4]+ y[14]*b[5]+ y[13]*b[6]+ y[12]*b[7]+ y[11]*b[8]+ y[10]*b[9]+ y[9]*b[10]+ y[8]*b[11]+ y[7]*b[12]+ y[6]*b[13]+ y[5]*b[14]+ y[4]*b[15]+ y[3]*b[16]+ y[2]*b[17]+ y[1]*b[18]+ y[0]*b[19];
        q[20]=y[20]*b[0]+ y[19]*b[1]+ y[18]*b[2]+ y[17]*b[3]+ y[16]*b[4]+ y[15]*b[5]+ y[14]*b[6]+ y[13]*b[7]+ y[12]*b[8]+ y[11]*b[9]+ y[10]*b[10]+ y[9]*b[11]+ y[8]*b[12]+ y[7]*b[13]+ y[6]*b[14]+ y[5]*b[15]+ y[4]*b[16]+ y[3]*b[17]+ y[2]*b[18]+ y[1]*b[19]+ y[0]*b[20];
        q[21]=y[21]*b[0]+ y[20]*b[1]+ y[19]*b[2]+ y[18]*b[3]+ y[17]*b[4]+ y[16]*b[5]+ y[15]*b[6]+ y[14]*b[7]+ y[13]*b[8]+ y[12]*b[9]+ y[11]*b[10]+ y[10]*b[11]+ y[9]*b[12]+ y[8]*b[13]+ y[7]*b[14]+ y[6]*b[15]+ y[5]*b[16]+ y[4]*b[17]+ y[3]*b[18]+ y[2]*b[19]+ y[1]*b[20]+ y[0]*b[21];
        q[22]=y[22]*b[0]+ y[21]*b[1]+ y[20]*b[2]+ y[19]*b[3]+ y[18]*b[4]+ y[17]*b[5]+ y[16]*b[6]+ y[15]*b[7]+ y[14]*b[8]+ y[13]*b[9]+ y[12]*b[10]+ y[11]*b[11]+ y[10]*b[12]+ y[9]*b[13]+ y[8]*b[14]+ y[7]*b[15]+ y[6]*b[16]+ y[5]*b[17]+ y[4]*b[18]+ y[3]*b[19]+ y[2]*b[20]+ y[1]*b[21]+ y[0]*b[22];
        q[23]=y[23]*b[0]+ y[22]*b[1]+ y[21]*b[2]+ y[20]*b[3]+ y[19]*b[4]+ y[18]*b[5]+ y[17]*b[6]+ y[16]*b[7]+ y[15]*b[8]+ y[14]*b[9]+ y[13]*b[10]+ y[12]*b[11]+ y[11]*b[12]+ y[10]*b[13]+ y[9]*b[14]+ y[8]*b[15]+ y[7]*b[16]+ y[6]*b[17]+ y[5]*b[18]+ y[4]*b[19]+ y[3]*b[20]+ y[2]*b[21]+ y[1]*b[22]+ y[0]*b[23];
        q[24]=y[24]*b[0]+ y[23]*b[1]+ y[22]*b[2]+ y[21]*b[3]+ y[20]*b[4]+ y[19]*b[5]+ y[18]*b[6]+ y[17]*b[7]+ y[16]*b[8]+ y[15]*b[9]+ y[14]*b[10]+ y[13]*b[11]+ y[12]*b[12]+ y[11]*b[13]+ y[10]*b[14]+ y[9]*b[15]+ y[8]*b[16]+ y[7]*b[17]+ y[6]*b[18]+ y[5]*b[19]+ y[4]*b[20]+ y[3]*b[21]+ y[2]*b[22]+ y[1]*b[23]+ y[0]*b[24];
        q[25]=y[25]*b[0]+ y[24]*b[1]+ y[23]*b[2]+ y[22]*b[3]+ y[21]*b[4]+ y[20]*b[5]+ y[19]*b[6]+ y[18]*b[7]+ y[17]*b[8]+ y[16]*b[9]+ y[15]*b[10]+ y[14]*b[11]+ y[13]*b[12]+ y[12]*b[13]+ y[11]*b[14]+ y[10]*b[15]+ y[9]*b[16]+ y[8]*b[17]+ y[7]*b[18]+ y[6]*b[19]+ y[5]*b[20]+ y[4]*b[21]+ y[3]*b[22]+ y[2]*b[23]+ y[1]*b[24]+ y[0]*b[25];
        q[26]=y[26]*b[0]+ y[25]*b[1]+ y[24]*b[2]+ y[23]*b[3]+ y[22]*b[4]+ y[21]*b[5]+ y[20]*b[6]+ y[19]*b[7]+ y[18]*b[8]+ y[17]*b[9]+ y[16]*b[10]+ y[15]*b[11]+ y[14]*b[12]+ y[13]*b[13]+ y[12]*b[14]+ y[11]*b[15]+ y[10]*b[16]+ y[9]*b[17]+ y[8]*b[18]+ y[7]*b[19]+ y[6]*b[20]+ y[5]*b[21]+ y[4]*b[22]+ y[3]*b[23]+ y[2]*b[24]+ y[1]*b[25]+ y[0]*b[26];
        q[27]=y[27]*b[0]+ y[26]*b[1]+ y[25]*b[2]+ y[24]*b[3]+ y[23]*b[4]+ y[22]*b[5]+ y[21]*b[6]+ y[20]*b[7]+ y[19]*b[8]+ y[18]*b[9]+ y[17]*b[10]+ y[16]*b[11]+ y[15]*b[12]+ y[14]*b[13]+ y[13]*b[14]+ y[12]*b[15]+ y[11]*b[16]+ y[10]*b[17]+ y[9]*b[18]+ y[8]*b[19]+ y[7]*b[20]+ y[6]*b[21]+ y[5]*b[22]+ y[4]*b[23]+ y[3]*b[24]+ y[2]*b[25]+ y[1]*b[26]+ y[0]*b[27];
        q[28]=y[28]*b[0]+ y[27]*b[1]+ y[26]*b[2]+ y[25]*b[3]+ y[24]*b[4]+ y[23]*b[5]+ y[22]*b[6]+ y[21]*b[7]+ y[20]*b[8]+ y[19]*b[9]+ y[18]*b[10]+ y[17]*b[11]+ y[16]*b[12]+ y[15]*b[13]+ y[14]*b[14]+ y[13]*b[15]+ y[12]*b[16]+ y[11]*b[17]+ y[10]*b[18]+ y[9]*b[19]+ y[8]*b[20]+ y[7]*b[21]+ y[6]*b[22]+ y[5]*b[23]+ y[4]*b[24]+ y[3]*b[25]+ y[2]*b[26]+ y[1]*b[27]+ y[0]*b[28];
        q[29]=y[29]*b[0]+ y[28]*b[1]+ y[27]*b[2]+ y[26]*b[3]+ y[25]*b[4]+ y[24]*b[5]+ y[23]*b[6]+ y[22]*b[7]+ y[21]*b[8]+ y[20]*b[9]+ y[19]*b[10]+ y[18]*b[11]+ y[17]*b[12]+ y[16]*b[13]+ y[15]*b[14]+ y[14]*b[15]+ y[13]*b[16]+ y[12]*b[17]+ y[11]*b[18]+ y[10]*b[19]+ y[9]*b[20]+ y[8]*b[21]+ y[7]*b[22]+ y[6]*b[23]+ y[5]*b[24]+ y[4]*b[25]+ y[3]*b[26]+ y[2]*b[27]+ y[1]*b[28]+ y[0]*b[29];
        q[30]=y[30]*b[0]+ y[29]*b[1]+ y[28]*b[2]+ y[27]*b[3]+ y[26]*b[4]+ y[25]*b[5]+ y[24]*b[6]+ y[23]*b[7]+ y[22]*b[8]+ y[21]*b[9]+ y[20]*b[10]+ y[19]*b[11]+ y[18]*b[12]+ y[17]*b[13]+ y[16]*b[14]+ y[15]*b[15]+ y[14]*b[16]+ y[13]*b[17]+ y[12]*b[18]+ y[11]*b[19]+ y[10]*b[20]+ y[9]*b[21]+ y[8]*b[22]+ y[7]*b[23]+ y[6]*b[24]+ y[5]*b[25]+ y[4]*b[26]+ y[3]*b[27]+ y[2]*b[28]+ y[1]*b[29]+ y[0]*b[30];
        q[31]=y[31]*b[0]+ y[30]*b[1]+ y[29]*b[2]+ y[28]*b[3]+ y[27]*b[4]+ y[26]*b[5]+ y[25]*b[6]+ y[24]*b[7]+ y[23]*b[8]+ y[22]*b[9]+ y[21]*b[10]+ y[20]*b[11]+ y[19]*b[12]+ y[18]*b[13]+ y[17]*b[14]+ y[16]*b[15]+ y[15]*b[16]+ y[14]*b[17]+ y[13]*b[18]+ y[12]*b[19]+ y[11]*b[20]+ y[10]*b[21]+ y[9]*b[22]+ y[8]*b[23]+ y[7]*b[24]+ y[6]*b[25]+ y[5]*b[26]+ y[4]*b[27]+ y[3]*b[28]+ y[2]*b[29]+ y[1]*b[30]+ y[0]*b[31];


        for i in range(32, 2046, 1):

            q[i]=y[i]*b[0]+ y[i-1]*b[1]+ y[i-2]*b[2]+ y[i-3]*b[3]+ y[i-4]*b[4]+ y[i-5]*b[5]+ y[i-6]*b[6]+ y[i-7]*b[7]+ y[i-8]*b[8]+ y[i-9]*b[9]+ y[i-10]*b[10]+ y[i-11]*b[11]+ y[i-12]*b[12]+ y[i-13]*b[13]+ y[i-14]*b[14]+ y[i-15]*b[15]+ y[i-16]*b[16]+ y[i-17]*b[17]+ y[i-18]*b[18]+ y[i-19]*b[19]+ y[i-20]*b[20]+ y[i-21]*b[21]+ y[i-22]*b[22]+ y[i-23]*b[23]+ y[i-24]*b[24]+ y[i-25]*b[25]+ y[i-26]*b[26]+ y[i-27]*b[27]+ y[i-28]*b[28]+ y[i-29]*b[29]+ y[i-30]*b[30]+ y[i-31]*b[31]+ y[i-32]*b[32]; 

        for i in range(0, 15, 1):

            j[i]=0;

        for i in range(16, 2046, 1):

            j[i]=y[i-16];

        # Calculando o envelope

        for i in range(0,2046):
            
            env1[i][k] = np.sqrt((q[i]**2)+(j[i]**2))

        for i in range(0,2046):
            env[i][k] = env1[i+16][k]; #deslocando vetor

        '''
        if k==0:
            # Exportando dados para TXT    
            with open('teste_python_sc1_env.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
                for i in range(0, 2046, 1):
                    arquivo.write(str(env[i][k]) + '\n')
        if k==0:
            # Exportando dados para TXT    
            with open('teste_python_sc1_env_sem_desloc.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
                for i in range(0, 2046, 1):
                    arquivo.write(str(env1[i][k]) + '\n')
        '''

    '''
    # Exportando dados para TXT    
    with open('teste_env_completo_python.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
        for k in range(0, 121, 1):
            for i in range(0, 2046, 1):
               arquivo.write(str(env[i][k]) + '\n')
    '''
    
    value = 3.823465047158225e+03 #valor máximo para todas as linhas e colunas
    print(value)
    
    for k in range(0, 121):
        
        #--------------------------------------------
        # Limite Superior, Inferior e Compressão Log
        #--------------------------------------------
        
        for i in range(0,2046):
            if env[i][k] > value: #limite superior
                env[i][k] = value;

            if env[i][k] < limiar_inf: #limite inferior
                env[i][k] = limiar_inf;

            env[i][k] = env[i][k] - limiar_inf;
            aux = value - limiar_inf;
            
            s[i][k] = 20*(np.log10(env[i][k]/aux)) #compressão log

            if s[i][k] < -30: #ajuste de faixa dinâmica
                s[i][k] = -30;
        
    # Exportando dados para TXT    
    with open('processamento_completo_env32_v2.txt', 'w') as arquivo: #com 'w': sobrescreve o anterior
        for k in range(0, 121, 1):
            for i in range(0, 2046, 1):
               arquivo.write(str(s[i][k]) + '\n')

    return s

processamento()
end = timeit.default_timer()
fim = time.time()

print("End: ", end)
print("Fim: ", fim)
print("Time: ", end-start)
print("Duração: ", fim-inicio)

#------------------------
# Plotando imagem de US
#------------------------

plt.imshow(s, extent=[0,2046,0,2046], cmap=plt.get_cmap('gray'))
plt.colorbar()
plt.show()

